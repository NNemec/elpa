  function solve_elpa1_evp_&
  &MATH_DATATTYPE&
  &_wrapper_&
  &PRECISION&
  & (na, nev, a, lda, ev, q, ldq, nblk, matrixCols, mpi_comm_rows, mpi_comm_cols, mpi_comm_all, &
     useGPU) result(success) bind(C,name="elpa_solve_evp_&
     &MATH_DATATYPE&
     &_1stage_&
     &PRECISION&
     &_precision")

    use, intrinsic :: iso_c_binding
    use elpa1

    implicit none
    integer(kind=c_int)                    :: success
    integer(kind=c_int), value, intent(in) :: na, nev, lda, ldq, nblk, matrixCols, mpi_comm_cols, mpi_comm_rows, mpi_comm_all
    integer(kind=c_int), value, intent(in) :: useGPU
    real(kind=C_DATATYPE_KIND)             :: ev(1:na)

#if REALCASE == 1

#ifdef USE_ASSUMED_SIZE
    real(kind=C_DATATYPE_KIND)             :: a(lda,*), q(ldq,*)
#else
    real(kind=C_DATATYPE_KIND)             :: a(1:lda,1:matrixCols), q(1:ldq,1:matrixCols)
#endif

#endif /* REALCASE */

#if COMPLEXCASE == 1

#ifdef USE_ASSUMED_SIZE
    complex(kind=C_DATATYPE_KIND)          :: a(lda,*), q(ldq,*)
#else
    complex(kind=C_DATATYPE_KIND)          :: a(1:lda,1:matrixCols), q(1:ldq,1:matrixCols)
#endif

#endif /* COMPLEXCASE == 1 */
    logical                                :: successFortran

    successFortran = elpa_solve_evp_&
    &MATH_DATATYPE&
    &_1stage_&
    &PRECISION &
    & (na, nev, a, lda, ev, q, ldq, nblk, matrixCols, mpi_comm_rows, mpi_comm_cols, mpi_comm_all, &
       useGPU == 1)

    if (successFortran) then
      success = 1
    else
      success = 0
    endif

  end function
