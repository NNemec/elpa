#if 0
!    This file is part of ELPA.
!
!    The ELPA library was originally created by the ELPA consortium,
!    consisting of the following organizations:
!
!    - Max Planck Computing and Data Facility (MPCDF), formerly known as
!      Rechenzentrum Garching der Max-Planck-Gesellschaft (RZG),
!    - Bergische Universität Wuppertal, Lehrstuhl für angewandte
!      Informatik,
!    - Technische Universität München, Lehrstuhl für Informatik mit
!      Schwerpunkt Wissenschaftliches Rechnen ,
!    - Fritz-Haber-Institut, Berlin, Abt. Theorie,
!    - Max-Plack-Institut für Mathematik in den Naturwissenschaften,
!      Leipzig, Abt. Komplexe Strukutren in Biologie und Kognition,
!      and
!    - IBM Deutschland GmbH
!
!    This particular source code file contains additions, changes and
!    enhancements authored by Intel Corporation which is not part of
!    the ELPA consortium.
!
!    More information can be found here:
!    http://elpa.mpcdf.mpg.de/
!
!    ELPA is free software: you can redistribute it and/or modify
!    it under the terms of the version 3 of the license of the
!    GNU Lesser General Public License as published by the Free
!    Software Foundation.
!
!    ELPA is distributed in the hope that it will be useful,
!    but WITHOUT ANY WARRANTY; without even the implied warranty of
!    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!    GNU Lesser General Public License for more details.
!
!    You should have received a copy of the GNU Lesser General Public License
!    along with ELPA.  If not, see <http://www.gnu.org/licenses/>
!
!    ELPA reflects a substantial effort on the part of the original
!    ELPA consortium, and we ask you to respect the spirit of the
!    license that we chose: i.e., please contribute any changes you
!    may have back to the original ELPA library distribution, and keep
!    any derivatives of ELPA under the same license that we chose for
!    the original distribution, the GNU Lesser General Public License.
!
!
! ELPA1 -- Faster replacements for ScaLAPACK symmetric eigenvalue routines
!
! Copyright of the original code rests with the authors inside the ELPA
! consortium. The copyright of any additional modifications shall rest
! with their original authors, but shall adhere to the licensing terms
! distributed along with the original code in the file "COPYING".
#endif

    subroutine M_trans_ev_real_PRECISSION(na, nqc, a, lda, tau, q, ldq, nblk, matrixCols, mpi_comm_rows, mpi_comm_cols)
    !-------------------------------------------------------------------------------
    !  trans_ev_real: Transforms the eigenvectors of a tridiagonal matrix back
    !                 to the eigenvectors of the original matrix
    !                 (like Scalapack Routine PDORMTR)
    !
    !  Parameters
    !
    !  na          Order of matrix a, number of rows of matrix q
    !
    !  nqc         Number of columns of matrix q
    !
    !  a(lda,matrixCols)    Matrix containing the Householder vectors (i.e. matrix a after tridiag_real)
    !              Distribution is like in Scalapack.
    !
    !  lda         Leading dimension of a
    !  matrixCols  local columns of matrix a and q
    !
    !  tau(na)     Factors of the Householder vectors
    !
    !  q           On input: Eigenvectors of tridiagonal matrix
    !              On output: Transformed eigenvectors
    !              Distribution is like in Scalapack.
    !
    !  ldq         Leading dimension of q
    !
    !  nblk        blocksize of cyclic distribution, must be the same in both directions!
    !
    !  mpi_comm_rows
    !  mpi_comm_cols
    !              MPI-Communicators for rows/columns
    !
    !-------------------------------------------------------------------------------
#ifdef HAVE_DETAILED_TIMINGS
      use timings
#endif
      use precision
      implicit none

      integer(kind=ik)           :: na, nqc, lda, ldq, nblk, matrixCols, mpi_comm_rows, mpi_comm_cols
      real(kind=REAL_DATATYPE)              :: tau(na)
#ifdef USE_ASSUMED_SIZE
      real(kind=REAL_DATATYPE)              :: a(lda,*), q(ldq,*)
#else
      real(kind=REAL_DATATYPE)              :: a(lda,matrixCols), q(ldq,matrixCols)
#endif

      integer(kind=ik)           :: max_stored_rows

      integer(kind=ik)           :: my_prow, my_pcol, np_rows, np_cols, mpierr
      integer(kind=ik)           :: totalblocks, max_blocks_row, max_blocks_col, max_local_rows, max_local_cols
      integer(kind=ik)           :: l_cols, l_rows, l_colh, nstor
      integer(kind=ik)           :: istep, i, n, nc, ic, ics, ice, nb, cur_pcol

      real(kind=REAL_DATATYPE), allocatable :: tmp1(:), tmp2(:), hvb(:), hvm(:,:)
      real(kind=REAL_DATATYPE), allocatable :: tmat(:,:), h1(:), h2(:)
      integer(kind=ik)           :: istat
      character(200)             :: errorMessage
#ifdef HAVE_DETAILED_TIMINGS
      call timer%start("trans_ev_real" // M_PRECISSION_SUFFIX)
#endif
#ifdef HAVE_DETAILED_TIMINGS
      call timer%start("mpi_communication")
#endif
      call mpi_comm_rank(mpi_comm_rows,my_prow,mpierr)
      call mpi_comm_size(mpi_comm_rows,np_rows,mpierr)
      call mpi_comm_rank(mpi_comm_cols,my_pcol,mpierr)
      call mpi_comm_size(mpi_comm_cols,np_cols,mpierr)
#ifdef HAVE_DETAILED_TIMINGS
      call timer%stop("mpi_communication")
#endif
      totalblocks = (na-1)/nblk + 1
      max_blocks_row = (totalblocks-1)/np_rows + 1
      max_blocks_col = ((nqc-1)/nblk)/np_cols + 1  ! Columns of q!

      max_local_rows = max_blocks_row*nblk
      max_local_cols = max_blocks_col*nblk

      max_stored_rows = (63/nblk+1)*nblk

      allocate(tmat(max_stored_rows,max_stored_rows), stat=istat, errmsg=errorMessage)
      if (istat .ne. 0) then
        print *,"trans_ev_real: error when allocating tmat "//errorMessage
        stop
      endif

      allocate(h1(max_stored_rows*max_stored_rows), stat=istat, errmsg=errorMessage)
      if (istat .ne. 0) then
        print *,"trans_ev_real: error when allocating h1 "//errorMessage
        stop
      endif

      allocate(h2(max_stored_rows*max_stored_rows), stat=istat, errmsg=errorMessage)
      if (istat .ne. 0) then
        print *,"trans_ev_real: error when allocating h2 "//errorMessage
        stop
      endif

      allocate(tmp1(max_local_cols*max_stored_rows), stat=istat, errmsg=errorMessage)
      if (istat .ne. 0) then
        print *,"trans_ev_real: error when allocating tmp1 "//errorMessage
        stop
      endif

      allocate(tmp2(max_local_cols*max_stored_rows), stat=istat, errmsg=errorMessage)
      if (istat .ne. 0) then
        print *,"trans_ev_real: error when allocating tmp2 "//errorMessage
        stop
      endif

      allocate(hvb(max_local_rows*nblk), stat=istat, errmsg=errorMessage)
      if (istat .ne. 0) then
        print *,"trans_ev_real: error when allocating hvn "//errorMessage
        stop
      endif

      allocate(hvm(max_local_rows,max_stored_rows), stat=istat, errmsg=errorMessage)
      if (istat .ne. 0) then
        print *,"trans_ev_real: error when allocating hvm "//errorMessage
        stop
      endif


!      if (useGPU) then
!        allocate(hvm1(max_local_rows*max_stored_rows))
!
!        allocate(tmat_dev(max_stored_rows,max_stored_rows))
!        allocate(hvm_dev(max_local_rows*max_stored_rows))
!        allocate(tmp_dev(max_local_cols*max_stored_rows))
!        allocate(q_dev(ldq,nqc))
!        q_dev = q
!      endif

      hvm = 0   ! Must be set to 0 !!!
      hvb = 0   ! Safety only

      l_cols = local_index(nqc, my_pcol, np_cols, nblk, -1) ! Local columns of q

      nstor = 0
!      if (useGPU) then
!        hvn_ubnd = 0
!      endif

      do istep=1,na,nblk

        ics = MAX(istep,3)
        ice = MIN(istep+nblk-1,na)
        if (ice<ics) cycle

        cur_pcol = pcol(istep, nblk, np_cols)

        nb = 0
        do ic=ics,ice

          l_colh = local_index(ic  , my_pcol, np_cols, nblk, -1) ! Column of Householder vector
          l_rows = local_index(ic-1, my_prow, np_rows, nblk, -1) ! # rows of Householder vector


          if (my_pcol==cur_pcol) then
            hvb(nb+1:nb+l_rows) = a(1:l_rows,l_colh)
            if (my_prow==prow(ic-1, nblk, np_rows)) then
              hvb(nb+l_rows) = 1.
            endif
          endif

          nb = nb+l_rows
        enddo

#ifdef WITH_MPI
#ifdef HAVE_DETAILED_TIMINGS
        call timer%start("mpi_communication")
#endif
        if (nb>0) &
            call MPI_Bcast(hvb, nb, M_MPI_REAL_PRECISSION, cur_pcol, mpi_comm_cols, mpierr)
#ifdef HAVE_DETAILED_TIMINGS
        call timer%stop("mpi_communication")
#endif
#endif /* WITH_MPI */
        nb = 0
        do ic=ics,ice
          l_rows = local_index(ic-1, my_prow, np_rows, nblk, -1) ! # rows of Householder vector
          hvm(1:l_rows,nstor+1) = hvb(nb+1:nb+l_rows)
!     if (useGPU) then
!            hvm_ubnd = l_rows
!     endif
          nstor = nstor+1
          nb = nb+l_rows
        enddo

        ! Please note: for smaller matix sizes (na/np_rows<=256), a value of 32 for nstor is enough!
        if (nstor+nblk>max_stored_rows .or. istep+nblk>na .or. (na/np_rows<=256 .and. nstor>=32)) then

          ! Calculate scalar products of stored vectors.
          ! This can be done in different ways, we use dsyrk

          tmat = 0
          if (l_rows>0) &
               call M_PRECISSION_SYRK('U', 'T', nstor, l_rows,   &
                                      M_CONST_1_0, hvm, ubound(hvm,dim=1),   &
                                      M_CONST_0_0, tmat, max_stored_rows)

          nc = 0
          do n=1,nstor-1
            h1(nc+1:nc+n) = tmat(1:n,n+1)
            nc = nc+n
          enddo
#ifdef WITH_MPI
#ifdef HAVE_DETAILED_TIMINGS
          call timer%start("mpi_communication")
#endif
          if (nc>0) call mpi_allreduce( h1, h2, nc, M_MPI_REAL_PRECISSION, MPI_SUM, mpi_comm_rows, mpierr)
#ifdef HAVE_DETAILED_TIMINGS
          call timer%stop("mpi_communication")
#endif
#else /* WITH_MPI */
          if (nc>0) h2 = h1
#endif /* WITH_MPI */
          ! Calculate triangular matrix T

          nc = 0
          tmat(1,1) = tau(ice-nstor+1)
          do n=1,nstor-1
            call M_PRECISSION_TRMV('L', 'T', 'N', n,  &
                                   tmat, max_stored_rows,  &
                                   h2(nc+1), 1)
            tmat(n+1,1:n) = -h2(nc+1:nc+n)*tau(ice-nstor+n+1)
            tmat(n+1,n+1) = tau(ice-nstor+n+1)
            nc = nc+n
          enddo

!     if (useGPU) then
!            hvm1(1:hvm_ubnd*nstor) = reshape(hvm(1:hvm_ubnd,1:nstor), (/ hvm_ubnd*nstor /))
!
!            hvm_dev(1:hvm_ubnd*nstor) = hvm1(1:hvm_ubnd*nstor)
!            tmat_dev = tmat
!     endif

          ! Q = Q - V * T * V**T * Q

          if (l_rows>0) then
            call M_PRECISSION_GEMM('T', 'N', nstor, l_cols, l_rows,  &
                                   M_CONST_1_0, hvm, ubound(hvm,dim=1), &
                                   q, ldq,  &
                                   M_CONST_0_0, tmp1, nstor)

          else
!       if (useGPU) then
!         tmp_dev(1:l_cols*nstor) = 0
!       else
              tmp1(1:l_cols*nstor) = 0
!       endif
          endif

!          if (useGPU) then
!     else
#ifdef WITH_MPI
#ifdef HAVE_DETAILED_TIMINGS
            call timer%start("mpi_communication")
#endif
            call mpi_allreduce(tmp1, tmp2, nstor*l_cols, M_MPI_REAL_PRECISSION, MPI_SUM, mpi_comm_rows, mpierr)
#ifdef HAVE_DETAILED_TIMINGS
            call timer%stop("mpi_communication")
#endif
#else
!            tmp2 = tmp1
#endif
!          endif ! useGPU

          if (l_rows>0) then
#ifdef WITH_MPI
            call M_PRECISSION_TRMM('L', 'L', 'N', 'N', nstor, l_cols,   &
                                   M_CONST_1_0, tmat, max_stored_rows,  &
                                   tmp2, nstor)
            call M_PRECISSION_GEMM('N', 'N', l_rows, l_cols, nstor,   &
                                   -M_CONST_1_0, hvm, ubound(hvm,dim=1),  &
                                   tmp2, nstor,   &
                                   M_CONST_1_0, q, ldq)
#else
            call M_PRECISSION_TRMM('L', 'L', 'N', 'N', nstor, l_cols,   &
                                   M_CONST_1_0, tmat, max_stored_rows,  &
                                   tmp1, nstor)
            call M_PRECISSION_GEMM('N', 'N', l_rows, l_cols, nstor,   &
                                   -M_CONST_1_0, hvm, ubound(hvm,dim=1), &
                                   tmp1, nstor,   &
                                   M_CONST_1_0, q, ldq)
#endif
          endif
          nstor = 0
        endif

      enddo

      deallocate(tmat, h1, h2, tmp1, tmp2, hvb, hvm, stat=istat, errmsg=errorMessage)
      if (istat .ne. 0) then
        print *,"trans_ev_real: error when deallocating hvm "//errorMessage
        stop
      endif

!      if (useGPU) then
!        q = q_dev
!   deallocate(q_dev, tmp_dev, hvm_dev, tmat_dev)
!      endif

#ifdef HAVE_DETAILED_TIMINGS
      call timer%stop("trans_ev_real" // M_PRECISSION_SUFFIX)
#endif

    end subroutine M_trans_ev_real_PRECISSION
