#!/home/elpa/python-3.6/bin/python3

from itertools import product
from subprocess import run, PIPE, CalledProcessError
from shutil import copyfile
from os import getenv
import sys

class Configure(object):
    compilers = ["intel", "gcc"]
    architectures = ["sse", "avx", "avx2", "avx512-knl"]
    logical_flags = ["mpi", "openmp", "assumedsize", "ftimings", "redirect", "singleprecision", "coverage", "debug"]

    def __init__(self, **kwargs):
        self.flags = kwargs

    def sensible(self):
        if self.conf("coverage") and not self.conf("compiler") == "gcc":
            return False
        if self.conf("coverage") and self.conf("debug"):
            return False
        return True

    def conf(self, flag):
        return self.flags[flag]

    def compiler(self):
        return {
            ("intel", False) : "ifort",
            ("intel", True)  : "mpiifort",
            ("gcc", False)   : "gfortran",
            ("gcc", True)    : "mpif90",
        }[(self.conf("compiler"), self.conf("mpi"))]


    def fcflags(self):
        flags = []

        # Debug
        if self.conf("debug"):
            if self.conf("compiler") == "intel":
                flags.append("-g -C -traceback -CA -CB -check all")
            if self.conf("compiler") == "gcc":
                flags.append("-g -fcheck=all")

        # Coverage
        if self.conf("compiler") == "gcc" and self.conf("coverage"):
            flags.append("--coverage")

        # Optimization
        flags.append("-O2")

        # Architecture
        if self.conf("compiler") == "intel":
            flags.append({
                "sse" : "-xSSE4.2",
                "avx" : "-xAVX",
                "avx2" : "-xCORE-AVX2",
                "avx512-knl" : "-xCORE-AVX512",
            }[self.conf("architecture")])
        if self.conf("compiler") == "gcc":
            flags.append({
                "sse" : "-march=nehalem",
                "avx" : "-march=sandybridge",
                "avx2" : "-march=haswell",
                "avx512-knl" : "-march=knl",
            }[self.conf("architecture")])

        return " ".join(flags)

    def cflags(self):
        flags = []

        # Debug
        if self.conf("debug"):
            flags.append("-g")

        # Coverage
        if self.conf("compiler") == "gcc" and self.conf("coverage"):
            flags.append("--coverage")

        # Optimization
        flags.append("-O2")

        return " ".join(flags)

    def mpi(self):
        if self.conf("mpi"):
            return "--with-mpi=yes"
        else:
            return "--with-mpi=no"

    def openmp(self):
        if self.conf("openmp"):
            return "--enable-openmp"
        else:
            return "--disable-openmp"

    def assumedsize(self):
        if self.conf("assumedsize"):
            return ["--enable-assumed-size"]
        else:
            return []

    def mkl_ldflags(self):
        """ This is probably hopeless """
        mkl_home = getenv("MKL_HOME")
        if not mkl_home:
            raise Exception("MKL_HOME environment variable os not set!")
        line = ["-L" + mkl_home + "/lib/intel64"]
        if self.conf("mpi"):
            line.append("-lmkl_scalapack_lp64")

        if self.conf("compiler") == "intel":
            line.append("-lmkl_intel_lp64")
        elif self.conf("compiler") == "gcc":
            line.append("-lmkl_gf_lp64")
        else:
            raise Exception("Unsupported compiler {0}".format(self.conf("compiler")))

        line.extend(["-lmkl_sequential", "-lmkl_core"])

        if self.conf("mpi"):
            line.append("-lmkl_blacs_intelmpi_lp64")

        line.extend(["-lpthread", "-lm"])
        line.append("-Wl,-rpath=" + mkl_home + "/lib/intel64")
        return " ".join(line)

    def mkl_fcflags(self):
        mkl_home = getenv("MKL_HOME")
        if not mkl_home:
            raise Exception("MKL_HOME environment variable os not set!")
        return "-I" + mkl_home + "/include/intel64/lp64"

    def ftimings(self):
        if self.conf("ftimings"):
            return ["--with-ftimings"]
        else:
            return []

    def redirect(self):
        if self.conf("redirect"):
            return ["--with-redirect"]
        else:
            return []

    def singleprecision(self):
        if self.conf("singleprecision"):
            return ["--enable-single-precision"]
        else:
            return []

    def cmd(self):
        line = ["./configure"]
        line.append("FC=" + self.compiler())
        line.append("FCFLAGS=" + self.fcflags())
        line.append("CFLAGS="  + self.cflags())
        line.append("SCALAPACK_FCFLAGS=" + self.mkl_fcflags())
        line.append("SCALAPACK_LDFLAGS=" + self.mkl_ldflags())
        line.append(self.mpi())
        line.append(self.openmp())
        line.extend(self.assumedsize())
        line.extend(self.ftimings())
        line.extend(self.redirect())
        line.extend(self.singleprecision())
        return line

    def __str__(self):
        fields = dict(self.flags)
        res = ""
        res += fields.pop("compiler")
        res += "_" + fields.pop("architecture")
        for field in sorted(fields):
            value = self.conf(field)
            if value is True:
                res += "_" + field
            elif value is False:
                res += "_no-" + field
            else:
                raise Exception("Please deal with value {0} for field {1}".format(value, field))
        return res

def pretty_print_cmd(cmd):
    res = []
    for arg in cmd:
        if " " in arg and not "=" in arg:
            res.append("\"{0}\"".format(arg))
        elif " " in arg:
            a, b = arg.split("=", 1)
            if not " " in a:
                res.append("{0}=\"{1}\"".format(a, b))
            else:
                res.append("\"{0}\"".format(arg))
        else:
            res.append(arg)
    return " ".join(res)

class CheckException(BaseException):
    pass

def check_and_print(cmd):
    print()
    print("Starting command: ",cmd)
    print()
    proc = run(cmd, shell=True, stdout=PIPE, stderr=PIPE)
    if proc.returncode != 0:
        sys.stdout.buffer.write(proc.stdout)
        sys.stderr.buffer.write(proc.stderr)
        raise CheckException("Command failed:\n {0}".format(pretty_print_cmd(cmd)))

for n, combination in enumerate(product(Configure.compilers, Configure.architectures, *([(False, True)] * len(Configure.logical_flags)))):
    compiler, architecture, *rest = combination
    kwargs = {}
    for flag, value in zip(Configure.logical_flags, rest):
        kwargs[flag] = value
    configure = Configure(compiler=compiler, architecture=architecture, **kwargs)

    print("Test {0}: {1}".format(n + 1, str(configure)))
    #print(pretty_print_cmd(configure.cmd()))

    if not configure.sensible():
        print("Skipped")
        print()
        continue

    try:
        check_and_print(configure.cmd())
        check_and_print(["make","-j","8"])
        check_and_print(["make","check","TEST_FLAGS=1500 50 16"])
        check_and_print(["make","distclean"])
    except CheckException as e:
        print("Error for testcase {0}:\n{1}".format(str(configure), e.args[0]))
        sys.exit(1)

    print()
