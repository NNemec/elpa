#!/home/elpa/python-3.6/bin/python3

from itertools import product
from subprocess import run, PIPE, CalledProcessError
from shutil import copyfile
from os import getenv
import argparse
import sys

class Configure(object):
    compilers = ["intel", "gcc"]
    architectures = ["sse", "avx", "avx2", "avx512-knl", "cuda"]
    logical_flags = ["mpi", "openmp", "assumedsize", "ftimings", "redirect", "singleprecision", "coverage", "debug"]

    def __init__(self, **kwargs):
        self.flags = kwargs

    def sensible(self):
        if self.conf("coverage") and not self.conf("compiler") == "gcc":
            return False
        if self.conf("coverage") and self.conf("debug"):
            return False
        if self.conf("openmp") and self.conf("architecture") == "cuda":
            return False
        return True

    def conf(self, flag):
        return self.flags[flag]

    def compiler(self):
        return {
            ("intel", False) : "ifort",
            ("intel", True)  : "mpiifort",
            ("gcc", False)   : "gfortran",
            ("gcc", True)    : "mpif90",
        }[(self.conf("compiler"), self.conf("mpi"))]


    def fcflags(self):
        flags = ["-g"]

        # Debug
        if self.conf("debug"):
            if self.conf("compiler") == "intel":
#                flags.append("-g -C -traceback -CA -CB -check all")
                flags.append("-g")
            if self.conf("compiler") == "gcc":
                flags.append("-g -fcheck=all")

        # Coverage
        if self.conf("compiler") == "gcc" and self.conf("coverage"):
            flags.append("--coverage")

        # Optimization
        flags.append("-O2")

        # Architecture
        if self.conf("compiler") == "intel":
            flags.append({
                "sse" : "-xSSE4.2",
                "avx" : "-xAVX",
                "avx2" : "-xCORE-AVX2",
                "avx512-knl" : "-xCORE-AVX512",
            }[self.conf("architecture")])
        if self.conf("compiler") == "gcc":
            flags.append({
                "sse" : "-march=nehalem",
                "avx" : "-march=sandybridge",
                "avx2" : "-march=haswell",
                "avx512-knl" : "-march=knl",
            }[self.conf("architecture")])

        return " ".join(flags)

    def cflags(self):
        flags = []

        # Debug
        if self.conf("debug"):
            flags.append("-g")

        # Coverage
        if self.conf("compiler") == "gcc" and self.conf("coverage"):
            flags.append("--coverage")

        # Optimization
        flags.append("-O2")

        return " ".join(flags)

    def mpi(self):
        if self.conf("mpi"):
            return "--with-mpi=yes"
        else:
            return "--with-mpi=no"

    def openmp(self):
        if self.conf("openmp"):
            return "--enable-openmp"
        else:
            return "--disable-openmp"

    def assumedsize(self):
        if self.conf("assumedsize"):
            return ["--enable-assumed-size"]
        else:
            return []

    def mkl_ldflags(self):
        """ This is probably hopeless """
        mkl_home = getenv("MKL_HOME")
        if not mkl_home:
            raise Exception("MKL_HOME environment variable os not set!")
        line = ["-L" + mkl_home + "/lib/intel64"]
        if self.conf("mpi"):
            line.append("-lmkl_scalapack_lp64")

        if self.conf("compiler") == "intel":
            line.append("-lmkl_intel_lp64")
        elif self.conf("compiler") == "gcc":
            line.append("-lmkl_gf_lp64")
        else:
            raise Exception("Unsupported compiler {0}".format(self.conf("compiler")))

        line.extend(["-lmkl_sequential", "-lmkl_core"])

        if self.conf("mpi"):
            line.append("-lmkl_blacs_intelmpi_lp64")

        line.extend(["-lpthread", "-lm"])
        line.append("-Wl,-rpath=" + mkl_home + "/lib/intel64")
        return " ".join(line)

    def mkl_fcflags(self):
        mkl_home = getenv("MKL_HOME")
        if not mkl_home:
            raise Exception("MKL_HOME environment variable os not set!")
        return "-I" + mkl_home + "/include/intel64/lp64"

    def ftimings(self):
        if self.conf("ftimings"):
            return ["--with-ftimings"]
        else:
            return []

    def redirect(self):
        if self.conf("redirect"):
            return ["--with-redirect"]
        else:
            return []

    def singleprecision(self):
        if self.conf("singleprecision"):
            return ["--enable-single-precision"]
        else:
            return []

    def cmd(self):
        line = ["./configure"]
        line.append("FC=" + self.compiler())
        line.append("FCFLAGS=" + self.fcflags())
        line.append("CFLAGS="  + self.cflags())
        line.append("SCALAPACK_FCFLAGS=" + self.mkl_fcflags())
        line.append("SCALAPACK_LDFLAGS=" + self.mkl_ldflags())
        line.append(self.mpi())
        line.append(self.openmp())
        line.extend(self.assumedsize())
        line.extend(self.ftimings())
        line.extend(self.redirect())
        line.extend(self.singleprecision())
        return line

    def __str__(self):
        fields = dict(self.flags)
        res = ""
        res += fields.pop("compiler")
        res += "_" + fields.pop("architecture")
        for field in sorted(fields):
            value = self.conf(field)
            if value is True:
                res += "_" + field
            elif value is False:
                res += "_no-" + field
            else:
                raise Exception("Please deal with value {0} for field {1}".format(value, field))
        return res

def pretty_print_cmd(cmd):
    res = []
    for arg in cmd:
        if " " in arg and not "=" in arg:
            res.append("\"{0}\"".format(arg))
        elif " " in arg:
            a, b = arg.split("=", 1)
            if not " " in a:
                res.append("{0}=\"{1}\"".format(a, b))
            else:
                res.append("\"{0}\"".format(arg))
        else:
            res.append(arg)
    return " ".join(res)

class CheckException(BaseException):
    pass

def check_and_print(cmd):
    proc = run(cmd, stdout=PIPE, stderr=PIPE, universal_newlines=True)
    if proc.returncode != 0:
        print("# {0}".format(pretty_print_cmd(cmd)))
        for line in proc.stdout.split("\n"):
            print("#  " + line)
        for line in proc.stderr.split("\n"):
            print("#  " + line)
        raise CheckException()


parser = argparse.ArgumentParser(description="Gitlab CI test script")
parser.add_argument("tests", choices=["all", "cpu", "emulated", "gpu"])
parser.add_argument("na",type=int,help="size of matrix")
parser.add_argument("nev",type=int,help="number of computed eigenvalues")
parser.add_argument("nblk",type=int,help="block size")
args = parser.parse_args()

if (args.tests == "all"):
    architectures = Configure.architectures
elif (args.tests == "cpu"):
    architectures = ["sse", "avx"]
elif (args.tests == "emulated"):
    architectures = ["avx2", "avx512-knl"]
elif (args.tests == "gpu"):
    architectures = ["gpu"]

N = len(Configure.compilers) * len(architectures) * 2**len(Configure.logical_flags)
print("1..{0}".format(N))

for n, combination in enumerate(product(Configure.compilers, architectures, *([(False, True)] * len(Configure.logical_flags)))):
    compiler, architecture, *rest = combination
    kwargs = {}
    for flag, value in zip(Configure.logical_flags, rest):
        kwargs[flag] = value
    configure = Configure(compiler=compiler, architecture=architecture, **kwargs)

    if not configure.sensible():
        print("ok {0} # SKIP {1}".format(n+1, configure))
        continue

    try:
        check_and_print(configure.cmd())
        check_and_print(["make","-j","8"])
        check = ["make","check"]
        if configure.conf("architecture") == "avx2":
            check = ["sde","-hsw","--"] + check + ["TEST_FLAGS="+str(args.na)+" "+str(args.nev)+" "+str(args.nblk)]
        elif configure.conf("architecture") == "avx512-knl":
            check = ["sde","-knl","--"] + check + ["TEST_FLAGS="+str(args.na)+" "+str(args.nev)+" "+str(args.nblk)]
        else:
            check = check + ["TEST_FLAGS"+str(args.na)+" "+str(args.nev)+" "+str(args.nblk)]
        check_and_print(check)
        check_and_print(["make","distclean"])
    except CheckException as e:
        print("not ok {0} # Error for testcase {1}".format(n + 1, str(configure)))
        print("Bail out!")
        sys.exit(1)
